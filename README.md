# Log_System

基于多设计模式下的同步&amp;异步日志系统

## 1. 项目介绍

本项目主要实现一个日志系统， 其主要支持以下功能：

- 支持多级别日志消息
- 支持同步日志和异步日志
- 支持可靠写入日志到控制台、文件以及滚动文件中
- 支持多线程程序并发写日志
- 支持扩展不同的日志落地目标地

## 2. 开发环境

* CentOS 7
* vscode/vim
* g++/gdb
* Makefile

## 3. 核心技术

* 类层次设计(继承和多态的应用)
* C++11(多线程、auto、智能指针、右值引用等)
* 双缓冲区
* 生产消费模型
* 多线程
* 设计模式(单例、工厂、代理、模板等)

## 4. 日志系统介绍

### 4.1 为什么需要日志系统

1. 生产环境的产品为了保证其稳定性及安全性是不允许开发人员附加调试器去排查问题， 可以借助日志系统来打印一些日志帮助开发人员解决问题
   上线客户端的产品出现bug无法复现并解决， 可以借助日志系统打印日志并上传到服务端帮助开发人员进行分析
2. 对于一些高频操作（如定时器、心跳包）在少量调试次数下可能无法触发我们想要的行为，通过断点的暂停方式，我们不得不重复操作几十次、上百次甚至更多，导致排查问题效率是非常低下， 可以借助打印日志的方式查问题
3. 在分布式、多线程/多进程代码中， 出现bug比较难以定位， 可以借助日志系统打印log帮助定位bug
4. 帮助首次接触项目代码的新开发人员理解代码的运行流程

### 4.2 日志系统技术实现

日志系统的技术实现主要包括三种类型:

1. 利用printf、std::cout等输出函数将日志信息打印到控制台
2. 对于大型商业化项目， 为了方便排查问题，我们一般会将日志输出到文件或者是数据库系统方便查
3. 询和分析日志， 主要分为同步日志和异步日志方式

#### 4.2.1 同步写日志

同步日志是指当输出日志时，必须等待日志输出语句执行完毕后，才能执行后面的业务逻辑语句，日志输出语句与程序的业务逻辑语句将在同一个线程运行。每次调用一次打印日志API就对应一次系统调用write写日志文件。

![1691756835062](image/README/1691756835062.png)

在高并发场景下，随着日志数量不断增加，同步日志系统容易产生系统瓶颈：

* 一方面，大量的日志打印陷入等量的write系统调用，有一定系统开销。
* 另一方面，使得打印日志的进程附带了大量同步的磁盘IO，影响程序性能。

#### 4.2.2 异步写日志

异步日志是指在进行日志输出时，日志输出语句与业务逻辑语句并不是在同一个线程中运行，而是有专门的线程用于进行日志输出操作。业务线程只需要将日志放到一个内存缓冲区中不用等待即可继续执行后续业务逻辑（作为日志的生产者），而日志的落地操作交给单独的日志线程去完成（作为日志
的消费者）, 这是一个典型的生产-消费模型。

![1691756954340](image/README/1691756954340.png)

这样做的好处是即使日志没有真的地完成输出也不会影响程序的主业务，可以提高程序的性能：

* 主线程调用日志打印接口成为非阻塞操作
* 同步的磁盘IO从主线程中剥离出来交给单独的线程完成

## 5. 日志系统框架设计

将一条消息，进行格式化成为指定格式的字符串后，写入到指定位置

本项目实现的是一个多日志器日志系统，主要实现的功能是让程序员能够轻松的将程序运行日志信息
落地到指定的位置，且支持同步与异步两种方式的日志落地方式。

### 5.1 模块划分

日志等级模块：对输出日志的等级进行划分，以便于控制日志的输出，并提供等级枚举转字符串功
能。
◦ OFF：关闭
◦ DEBUG：调试，调试时的关键信息输出。
◦ INFO：提示，普通的提示型日志信息。
◦ WARN：警告，不影响运行，但是需要注意一下的日志。
◦ ERROR：错误，程序运行出现错误的日志
◦ FATAL：致命，一般是代码异常导致程序无法继续推进运行的日志
• 日志消息模块：中间存储日志输出所需的各项要素信息
◦ 时间：描述本条日志的输出时间。
◦ 线程ID：描述本条日志是哪个线程输出的。
◦ 日志等级：描述本条日志的等级。
◦ 日志数据：本条日志的有效载荷数据。
